@startuml State Management
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title State Management Architecture

legend top
  **State Management Architecture Overview:**

  üèóÔ∏è **Multi-Layer State**: Different types of state managed at appropriate layers
  üîÑ **Unidirectional Flow**: State changes flow in one direction for predictability
  üìä **Single Source of Truth**: Each piece of state has one authoritative source
  üß™ **Testable State**: State management is easily testable and debuggable
  ‚ö° **Performance Optimized**: Minimal re-renders and efficient updates

  **State Management Principles:**
  ‚úÖ Local state for component-specific data
  ‚úÖ Global state for shared application data
  ‚úÖ Server state for cached API data
  ‚úÖ Form state for user input management
  ‚úÖ URL state for navigation and routing
end legend

package "Presentation Layer" as Presentation {
  class "React Component" as Component {
    - localState: useState
    - formState: useForm
    + render()
  }

  class "Custom Hooks" as Hooks {
    + useUsers()
    + useUserApproval()
    + useUserValidation()
  }
}

note right of Presentation
  **Presentation Layer State:**

  üé® **React Component State**:
  ‚Ä¢ Local state (useState) for UI-specific data
  ‚Ä¢ Form state (useForm) for user input management
  ‚Ä¢ Loading states for async operations
  ‚Ä¢ Modal and dialog states
  ‚Ä¢ Component-specific UI state

  ü™ù **Custom Hooks**:
  ‚Ä¢ Encapsulate business logic and state
  ‚Ä¢ Provide clean interface to components
  ‚Ä¢ Handle complex state interactions
  ‚Ä¢ Manage side effects and subscriptions
  ‚Ä¢ Reusable across multiple components

  **State Types**:
  ‚Ä¢ UI state (modals, loading, errors)
  ‚Ä¢ Form state (input values, validation)
  ‚Ä¢ Component state (expanded, selected)
  ‚Ä¢ Temporary state (animations, transitions)
end note

package "Application Layer" as Application {
  package "Zustand Stores" as ZustandStores {
    class "AuthStore" as AuthStore {
      - user: AdminUser (nullable)
      - permissions: Permission[]
      - isAuthenticated: boolean
      + login(credentials): void
      + logout(): void
      + refreshTokens(): void
    }

    class "UserStore" as UserStore {
      - users: AdminUser[]
      - selectedUsers: string[]
      - filters: UserFilters
      + setUsers(users): void
      + addUser(user): void
      + updateUser(user): void
    }

    class "PermissionStore" as PermissionStore {
      - permissions: Permission[]
      - roles: Role[]
      + fetchPermissions(): void
      + checkPermission(resource, action): boolean
    }
  }

  package "TanStack Query" as TanStackQuery {
    class "useQuery" as UseQuery {
      + data: Any
      + isLoading: boolean
      + error: Error
      + refetch(): void
    }

    class "useMutation" as UseMutation {
      + mutate(data): void
      + isLoading: boolean
      + error: Error
      + onSuccess: callback
    }
  }
}

note right of Application
  **Application Layer State:**

  üè™ **Zustand Stores**:
  ‚Ä¢ Global state management for application data
  ‚Ä¢ Selective subscriptions to prevent unnecessary re-renders
  ‚Ä¢ Immutable state updates for predictability
  ‚Ä¢ DevTools integration for debugging
  ‚Ä¢ Lightweight and performant

  üìä **TanStack Query**:
  ‚Ä¢ Server state caching and synchronization
  ‚Ä¢ Background refetching for fresh data
  ‚Ä¢ Optimistic updates for better UX
  ‚Ä¢ Request deduplication and caching
  ‚Ä¢ Error handling and retry logic

  **State Categories**:
  ‚Ä¢ **Auth State**: User authentication and permissions
  ‚Ä¢ **User State**: User management and selection
  ‚Ä¢ **Permission State**: Role-based access control
  ‚Ä¢ **Server State**: Cached API data and mutations
  ‚Ä¢ **UI State**: Global UI preferences and settings
end note

package "Infrastructure Layer" as Infrastructure {
  package "API Services" as APIServices {
    class "AdminUserService" as UserService {
      + getAllUsers(filters): AdminUser[]
      + approveUser(userId, data): AdminUser
    }

    class "AuthService" as AuthService {
      + login(credentials): AuthResponse
      + refreshToken(token): RefreshResponse
    }
  }

  class "Local Storage" as LocalStorage {
    + getItem(key): string
    + setItem(key, value): void
    + removeItem(key): void
  }
}

note right of Infrastructure
  **Infrastructure Layer State:**

  üåê **API Services**:
  ‚Ä¢ Handle server state synchronization
  ‚Ä¢ Manage API requests and responses
  ‚Ä¢ Implement caching strategies
  ‚Ä¢ Handle error states and retries
  ‚Ä¢ Transform data between API and domain models

  üíæ **Local Storage**:
  ‚Ä¢ Persist state across browser sessions
  ‚Ä¢ Store user preferences and settings
  ‚Ä¢ Cache frequently accessed data
  ‚Ä¢ Handle offline state management
  ‚Ä¢ Provide fallback for server state

  **Data Sources**:
  ‚Ä¢ **API State**: Server-side data and mutations
  ‚Ä¢ **Local Storage**: Persistent client-side data
  ‚Ä¢ **Session Storage**: Temporary session data
  ‚Ä¢ **IndexedDB**: Large structured data storage
  ‚Ä¢ **Cache**: In-memory data caching
end note

package "State Flow" as StateFlow {
  note "1. User Action" as UserAction
  note "2. Component State Update" as ComponentUpdate
  note "3. Hook State Update" as HookUpdate
  note "4. Store State Update" as StoreUpdate
  note "5. API Call" as APICall
  note "6. Server Response" as ServerResponse
  note "7. Cache Update" as CacheUpdate
  note "8. UI Re-render" as UIRerender
}

note right of StateFlow
  **State Flow Process:**

  üîÑ **Unidirectional Data Flow**:
  1. **User Action**: User interacts with UI
  2. **Component Update**: Local state changes
  3. **Hook Processing**: Business logic execution
  4. **Store Update**: Global state synchronization
  5. **API Call**: Server communication
  6. **Server Response**: Data received
  7. **Cache Update**: State persistence
  8. **UI Re-render**: Visual updates

  üìä **State Synchronization**:
  ‚Ä¢ Local state updates immediately
  ‚Ä¢ Global state updates after validation
  ‚Ä¢ Server state updates after API response
  ‚Ä¢ Cache updates for persistence
  ‚Ä¢ UI updates reflect all state changes

  üõ°Ô∏è **Error Handling**:
  ‚Ä¢ Validation errors prevent state updates
  ‚Ä¢ Network errors trigger retry logic
  ‚Ä¢ Fallback states for failed operations
  ‚Ä¢ User feedback for all state changes
end note

' Relationships
Component --> Hooks : uses
Hooks --> ZustandStores : subscribes to
Hooks --> TanStackQuery : uses
TanStackQuery --> APIServices : calls
ZustandStores --> LocalStorage : persists to

' State flow
UserAction --> ComponentUpdate
ComponentUpdate --> HookUpdate
HookUpdate --> StoreUpdate
StoreUpdate --> APICall
APICall --> ServerResponse
ServerResponse --> CacheUpdate
CacheUpdate --> UIRerender

' Store relationships
AuthStore --> AuthService : calls
UserStore --> UserService : calls
PermissionStore --> AuthService : calls

' Query relationships
UseQuery --> UserService : calls
UseMutation --> UserService : calls

note as N_StateManagementPatterns
  **State Management Patterns:**

  üéØ **State Selection Patterns**:
  ‚Ä¢ **Local State**: Component-specific UI state
  ‚Ä¢ **Global State**: Shared application state
  ‚Ä¢ **Server State**: Cached API data
  ‚Ä¢ **Form State**: User input management
  ‚Ä¢ **URL State**: Navigation and routing

  üîÑ **Update Patterns**:
  ‚Ä¢ **Immediate Updates**: Local state changes
  ‚Ä¢ **Optimistic Updates**: UI updates before API response
  ‚Ä¢ **Pessimistic Updates**: UI updates after API response
  ‚Ä¢ **Batch Updates**: Multiple state changes together
  ‚Ä¢ **Debounced Updates**: Delayed updates for performance

  üõ°Ô∏è **Error Handling Patterns**:
  ‚Ä¢ **Error Boundaries**: Catch and handle errors
  ‚Ä¢ **Fallback States**: Default states for errors
  ‚Ä¢ **Retry Logic**: Automatic retry for failed operations
  ‚Ä¢ **User Feedback**: Clear error messages
  ‚Ä¢ **State Recovery**: Restore previous valid state
end note

Component .. N_StateManagementPatterns
Hooks .. N_StateManagementPatterns
ZustandStores .. N_StateManagementPatterns
TanStackQuery .. N_StateManagementPatterns

note as N_ImplementationExample
  **State Management Implementation Example:**

  <code>
  // Zustand Store
  const useAuthStore = create((set, get) =&gt; ({
    user: null,
    permissions: [],
    isAuthenticated: false,

    login: async (credentials) =&gt; {
      set({ isLoading: true });
      try {
        const response = await authService.login(credentials);
        set({
          user: response.user,
          permissions: response.permissions,
          isAuthenticated: true,
          isLoading: false
        });
      } catch (error) {
        set({ error, isLoading: false });
      }
    },

    logout: () =&gt; {
      set({ user: null, permissions: [], isAuthenticated: false });
    }
  }));

  // TanStack Query
  const useUsers = (filters) =&gt; {
    return useQuery({
      queryKey: ['users', filters],
      queryFn: () =&gt; userService.getAllUsers(filters),
      staleTime: 5 * 60 * 1000,
    });
  };

  // Custom Hook
  const useUserApproval = () =&gt; {
    const queryClient = useQueryClient();

    return useMutation({
      mutationFn: (data) =&gt; userService.approveUser(data.userId, data),
      onSuccess: (newUser) =&gt; {
        queryClient.setQueryData(['users'], (old) =&gt;
          old?.map(user =&gt; user.id === newUser.id ? newUser : user)
        );
      },
    });
  };

  // Component Usage
  const UserManagementPage = () =&gt; {
    const { user, isAuthenticated } = useAuthStore();
    const { data: users, isLoading } = useUsers(filters);
    const approveUser = useUserApproval();

    if (!isAuthenticated) return &lt;LoginPage /&gt;;

    return (
      &lt;div&gt;
        {isLoading ? &lt;LoadingSpinner /&gt; : &lt;UserTable users={users} /&gt;}
      &lt;/div&gt;
    );
  };
  </code>
end note

Presentation .. N_ImplementationExample
Application .. N_ImplementationExample
Infrastructure .. N_ImplementationExample
StateFlow .. N_ImplementationExample

@enduml
