@startuml Use Case Pattern
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title Use Case Pattern Implementation

legend top
  **Use Case Pattern Overview:**

  ðŸŽ¯ **Business Logic Encapsulation**: Each use case represents a specific business operation
  ðŸ”„ **Clean Architecture**: Use cases sit in the application layer, orchestrating domain and infrastructure
  ðŸ§ª **Testability**: Use cases are easily testable with clear inputs and outputs
  ðŸ“¦ **Single Responsibility**: Each use case has one clear purpose and responsibility
  ðŸ”§ **Dependency Inversion**: Use cases depend on abstractions, not concrete implementations

  **Key Benefits:**
  âœ… Clear business logic organization
  âœ… Easy testing and mocking
  âœ… Reusable business operations
  âœ… Clean separation of concerns
  âœ… Framework-independent core logic
end legend

package "Domain Layer" as Domain {
  interface "UserManagementUseCase" as IUserManagement {
    + getAllUsers(filters) : AdminUser[]
    + approveUser(userId, data) : AdminUser
    + rejectUser(userId) : AdminUser
    + updateUser(userId, data) : AdminUser
    + deleteUser(userId) : void
  }
}

note right of Domain
  **Domain Layer - Use Case Interface:**

  ðŸ›ï¸ **Pure Business Logic**:
  â€¢ Defines business operations as interfaces
  â€¢ No implementation details or dependencies
  â€¢ Framework-independent contracts
  â€¢ Clear input/output specifications

  ðŸ“‹ **Interface Responsibilities**:
  â€¢ Define business operation contracts
  â€¢ Specify input and output types
  â€¢ Document business rules and constraints
  â€¢ Enable dependency inversion

  ðŸŽ¯ **Use Case Interface Benefits**:
  â€¢ Clear business operation boundaries
  â€¢ Easy to understand and maintain
  â€¢ Enables multiple implementations
  â€¢ Supports testing and mocking
end note

package "Application Layer" as Application {
  class "UserManagementUseCaseImpl" as UserManagementImpl {
    - userService : IUserService
    + getAllUsers(filters) : AdminUser[]
    + approveUser(userId, data) : AdminUser
    + rejectUser(userId) : AdminUser
    + updateUser(userId, data) : AdminUser
    + deleteUser(userId) : void
    - validateFilters(filters) : Any
    - validateApprovalData(data) : void
  }

  class "UseCaseFactory" as Factory {
    - static userService : IUserService
    - static userManagementUseCase : UserManagementUseCase
    + static setUserService(service) : void
    + static getUserManagementUseCase() : UserManagementUseCase
    + static initialize(service) : void
  }
}

note right of Application
  **Application Layer - Use Case Implementation:**

  ðŸŽ¯ **Business Logic Implementation**:
  â€¢ Implements domain interfaces
  â€¢ Contains business rules and validation
  â€¢ Orchestrates domain and infrastructure layers
  â€¢ Handles business-specific error scenarios

  ðŸ”§ **Use Case Implementation Features**:
  â€¢ Input validation and sanitization
  â€¢ Business rule enforcement
  â€¢ Error handling and recovery
  â€¢ Data transformation between layers
  â€¢ Transaction management

  ðŸ­ **Factory Pattern**:
  â€¢ Centralized use case creation
  â€¢ Dependency injection management
  â€¢ Service configuration
  â€¢ Singleton pattern for use cases

  ðŸ“Š **Implementation Benefits**:
  â€¢ Clear business logic organization
  â€¢ Easy testing with dependency injection
  â€¢ Reusable business operations
  â€¢ Clean separation of concerns
end note

package "Infrastructure Layer" as Infrastructure {
  interface "IUserService" as IUserService {
    + getAllUsers(filters) : AdminUser[]
    + approveUser(userId, data) : AdminUser
    + rejectUser(userId) : AdminUser
    + updateUser(userId, data) : AdminUser
    + deleteUser(userId) : void
  }

  class "AdminUserService" as UserService {
    - apiService : ApiService
    + getAllUsers(filters) : AdminUser[]
    + approveUser(userId, data) : AdminUser
    + rejectUser(userId) : AdminUser
    + updateUser(userId, data) : AdminUser
    + deleteUser(userId) : void
  }
}

note right of Infrastructure
  **Infrastructure Layer - Service Implementation:**

  ðŸŒ **External Communication**:
  â€¢ Handles API calls and data persistence
  â€¢ Manages network requests and responses
  â€¢ Implements caching and error handling
  â€¢ Transforms data between API and domain models

  ðŸ”Œ **Service Interface**:
  â€¢ Defines contract for external dependencies
  â€¢ Enables dependency inversion
  â€¢ Supports multiple implementations
  â€¢ Facilitates testing and mocking

  ðŸ—ï¸ **Service Implementation**:
  â€¢ Concrete implementation of service interface
  â€¢ Handles HTTP requests and responses
  â€¢ Manages data transformation
  â€¢ Implements error handling and retry logic

  ðŸ“Š **Infrastructure Benefits**:
  â€¢ Clean separation from business logic
  â€¢ Easy to swap implementations
  â€¢ Testable with mock services
  â€¢ Reusable across different use cases
end note

package "Presentation Layer" as Presentation {
  class "useUsers Hook" as UseUsersHook {
    + useUsers(filters) : UseQueryResult
  }

  class "useUserApproval Hook" as UseUserApprovalHook {
    + useUserApproval() : UseMutationResult
  }
}

note right of Presentation
  **Presentation Layer - React Hooks:**

  âš›ï¸ **React Integration**:
  â€¢ Custom hooks that consume use cases
  â€¢ Integrates with React Query for data fetching
  â€¢ Handles loading and error states
  â€¢ Provides clean interface to components

  ðŸª **Hook Responsibilities**:
  â€¢ Encapsulate use case execution
  â€¢ Manage React Query integration
  â€¢ Handle state management
  â€¢ Provide error handling

  ðŸ“Š **Hook Benefits**:
  â€¢ Reusable business logic
  â€¢ Clean component interface
  â€¢ Automatic state management
  â€¢ Easy testing and mocking

  ðŸ”„ **Data Flow**:
  â€¢ Hooks call use cases through factory
  â€¢ Use cases execute business logic
  â€¢ Results are cached by React Query
  â€¢ Components receive data and state
end note

' Relationships
UserManagementImpl ..|> IUserManagement : implements
UserManagementImpl --> IUserService : depends on
UserService ..|> IUserService : implements
Factory --> UserManagementImpl : creates
Factory --> UserService : manages

UseUsersHook --> Factory : uses
UseUserApprovalHook --> Factory : uses

note as N_ImplementationExample
  **Use Case Pattern Implementation Example:**

  <code>
  // Domain Layer - Interface
  interface UserManagementUseCase {
    approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt;;
  }

  // Application Layer - Implementation
  class UserManagementUseCaseImpl implements UserManagementUseCase {
    constructor(private userService: IUserService) {}

    async approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt; {
      // Business logic validation
      this.validateApprovalData(data);

      // Check business rules
      if (data.reason.length &lt; 10) {
        throw new Error('Approval reason must be at least 10 characters');
      }

      // Execute business operation
      const approvedUser = await this.userService.approveUser(userId, data);

      // Post-processing business logic
      this.logUserApproval(approvedUser, data);

      return approvedUser;
    }

    private validateApprovalData(data: UserApprovalRequest): void {
      if (!data.reason) {
        throw new Error('Approval reason is required');
      }
    }

    private logUserApproval(user: AdminUser, data: UserApprovalRequest): void {
      console.log(`User ${user.id} approved with reason: ${data.reason}`);
    }
  }

  // Infrastructure Layer - Service
  class AdminUserService implements IUserService {
    constructor(private apiService: ApiService) {}

    async approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt; {
      const response = await this.apiService.put(`/users/${userId}/approve`, data);
      return this.mapToAdminUser(response.data);
    }

    private mapToAdminUser(apiData: any): AdminUser {
      return {
        id: apiData.id,
        email: apiData.email,
        status: apiData.status,
      };
    }
  }

  // Presentation Layer - Hook
  const useUserApproval = () =&gt; {
    return useMutation({
      mutationFn: async (data: { userId: string; approvalData: UserApprovalRequest }) =&gt; {
        const useCase = UseCaseFactory.getUserManagementUseCase();
        return await useCase.approveUser(data.userId, data.approvalData);
      },
      onSuccess: (user) =&gt; {
        queryClient.invalidateQueries(['users']);
        toast.success(`User ${user.email} approved successfully`);
      },
      onError: (error) =&gt; {
        toast.error(`Failed to approve user: ${error.message}`);
      }
    });
  };
  </code>
end note

Domain .. N_ImplementationExample
Application .. N_ImplementationExample
Infrastructure .. N_ImplementationExample
Presentation .. N_ImplementationExample

@enduml
