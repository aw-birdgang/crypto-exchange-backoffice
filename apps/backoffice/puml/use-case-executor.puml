@startuml Use Case Executor
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title Use Case Executor Pattern

legend top
  **Use Case Executor Pattern Overview:**

  üèóÔ∏è **Cross-Cutting Concerns**: Handles logging, performance monitoring, caching, and validation
  üîÑ **Middleware Pipeline**: Executes middlewares before and after use case execution
  üìä **Observability**: Provides comprehensive monitoring and debugging capabilities
  üõ°Ô∏è **Error Handling**: Centralized error handling and recovery mechanisms
  ‚ö° **Performance**: Optimizes use case execution with caching and monitoring

  **Key Benefits:**
  ‚úÖ Separation of concerns
  ‚úÖ Reusable middleware components
  ‚úÖ Centralized cross-cutting logic
  ‚úÖ Easy testing and debugging
  ‚úÖ Performance monitoring and optimization
end legend

package "Use Case Executor" as Executor {
  interface "UseCaseExecutor" as IExecutor {
    + execute(useCase, context) : UseCaseResult
  }

  class "UseCaseExecutorImpl" as ExecutorImpl {
    - middlewares : UseCaseMiddleware[]
    + execute(useCase, context) : UseCaseResult
    + addMiddleware(middleware) : void
  }

  class "UseCaseContext" as Context {
    + requestId : String
    + timestamp : Date
    + metadata : Map
  }

  class "UseCaseResult" as Result {
    + success : boolean
    + data : Any
    + error : UseCaseError
    + metadata : ExecutionMetadata
  }
}

note right of Executor
  **Use Case Executor Core:**

  üéØ **UseCaseExecutor Interface**:
  ‚Ä¢ Defines contract for use case execution
  ‚Ä¢ Provides execute method for use cases
  ‚Ä¢ Ensures consistent execution pattern
  ‚Ä¢ Enables dependency injection

  üèóÔ∏è **UseCaseExecutorImpl**:
  ‚Ä¢ Manages middleware pipeline
  ‚Ä¢ Executes use cases with cross-cutting concerns
  ‚Ä¢ Handles error propagation
  ‚Ä¢ Provides execution context

  üìã **UseCaseContext**:
  ‚Ä¢ Contains execution metadata
  ‚Ä¢ Tracks request ID and timestamp
  ‚Ä¢ Stores custom metadata
  ‚Ä¢ Passes data between middlewares

  üìä **UseCaseResult**:
  ‚Ä¢ Standardized result format
  ‚Ä¢ Success/failure indication
  ‚Ä¢ Error information
  ‚Ä¢ Execution metadata
end note

package "Middlewares" as Middlewares {
  interface "UseCaseMiddleware" as IMiddleware {
    + before(context) : UseCaseContext
    + after(result, context) : UseCaseResult
    + onError(error, context) : void
  }

  class "LoggingMiddleware" as LoggingMiddleware {
    - logger : Function
    + before(context) : UseCaseContext
    + after(result, context) : UseCaseResult
    + onError(error, context) : void
  }

  class "PerformanceMiddleware" as PerformanceMiddleware {
    - performanceData : Map
    + before(context) : UseCaseContext
    + after(result, context) : UseCaseResult
    + getPerformanceStats(useCaseName) : PerformanceStats
  }

  class "CachingMiddleware" as CachingMiddleware {
    - cache : Map
    - defaultTtl : int
    + before(context) : UseCaseContext
    + after(result, context) : UseCaseResult
    + invalidateCache(pattern) : void
  }

  class "ValidationMiddleware" as ValidationMiddleware {
    - validators : Map
    + before(context) : UseCaseContext
    + after(result, context) : UseCaseResult
    + onError(error, context) : void
  }
}

note right of Middlewares
  **Middleware Components:**

  üìù **LoggingMiddleware**:
  ‚Ä¢ Logs use case execution start/end
  ‚Ä¢ Records input parameters and results
  ‚Ä¢ Handles error logging
  ‚Ä¢ Configurable log levels

  ‚è±Ô∏è **PerformanceMiddleware**:
  ‚Ä¢ Measures execution time
  ‚Ä¢ Collects performance statistics
  ‚Ä¢ Tracks memory usage
  ‚Ä¢ Provides performance insights

  üíæ **CachingMiddleware**:
  ‚Ä¢ Implements result caching
  ‚Ä¢ Manages cache invalidation
  ‚Ä¢ Configurable TTL settings
  ‚Ä¢ Cache key generation

  ‚úÖ **ValidationMiddleware**:
  ‚Ä¢ Validates input parameters
  ‚Ä¢ Enforces business rules
  ‚Ä¢ Provides validation errors
  ‚Ä¢ Custom validator support
end note

package "Factory" as Factory {
  class "UseCaseExecutorFactory" as ExecutorFactory {
    + createDefault() : UseCaseExecutorImpl
    + createWithMiddlewares(middlewares) : UseCaseExecutorImpl
  }
}

package "Usage Example" as Usage {
  class "useUsers Hook" as UseUsersHook {
    + useUsers(filters) : UseQueryResult
  }

  class "executeUseCase Helper" as ExecuteHelper {
    + executeUseCase(useCaseName, useCaseFn, params) : Any
  }
}

note right of Factory
  **Factory Pattern:**

  üè≠ **UseCaseExecutorFactory**:
  ‚Ä¢ Creates configured executor instances
  ‚Ä¢ Provides default middleware setup
  ‚Ä¢ Enables custom middleware configuration
  ‚Ä¢ Simplifies executor creation

  **Factory Methods**:
  ‚Ä¢ createDefault(): Creates executor with standard middlewares
  ‚Ä¢ createWithMiddlewares(): Creates executor with custom middlewares
  ‚Ä¢ createForTesting(): Creates executor for unit tests
  ‚Ä¢ createForProduction(): Creates optimized executor for production
end note

note right of Usage
  **Usage Examples:**

  ü™ù **useUsers Hook**:
  ‚Ä¢ Integrates with React Query
  ‚Ä¢ Uses executor for use case execution
  ‚Ä¢ Handles loading and error states
  ‚Ä¢ Provides cached data

  üîß **executeUseCase Helper**:
  ‚Ä¢ Simplifies use case execution
  ‚Ä¢ Handles executor configuration
  ‚Ä¢ Provides error handling
  ‚Ä¢ Enables easy testing
end note

' Relationships
ExecutorImpl ..|> IExecutor : implements
LoggingMiddleware ..|> IMiddleware : implements
PerformanceMiddleware ..|> IMiddleware : implements
CachingMiddleware ..|> IMiddleware : implements
ValidationMiddleware ..|> IMiddleware : implements

ExecutorImpl --> IMiddleware : uses
ExecutorFactory --> ExecutorImpl : creates
UseUsersHook --> ExecuteHelper : uses
ExecuteHelper --> ExecutorImpl : uses

' Execution flow note (standalone note + links)
note as N_ExecFlow
  **Execution Flow Process:**

  üîÑ **Middleware Pipeline**:
  1. **Before Middlewares**: Logging, validation, caching
  2. **Use Case Execution**: Business logic execution
  3. **After Middlewares**: Caching, performance, logging
  4. **Error Handling**: Error processing and recovery

  üìä **Execution Steps**:
  ‚Ä¢ Context creation and validation
  ‚Ä¢ Middleware pre-processing
  ‚Ä¢ Use case execution
  ‚Ä¢ Middleware post-processing
  ‚Ä¢ Result formatting and return

  üõ°Ô∏è **Error Handling**:
  ‚Ä¢ Middleware error handling
  ‚Ä¢ Use case error propagation
  ‚Ä¢ Error logging and monitoring
  ‚Ä¢ Graceful error recovery
end note
ExecutorImpl .. N_ExecFlow
Middlewares .. N_ExecFlow

note as N_ImplementationExample
  **Use Case Executor Implementation Example:**

  <code>
  // UseCaseExecutor Interface
  interface UseCaseExecutor {
    execute&lt;T&gt;(useCase: UseCase&lt;T&gt;, context: UseCaseContext): Promise&lt;UseCaseResult&lt;T&gt;&gt;;
  }

  // UseCaseExecutorImpl
  class UseCaseExecutorImpl implements UseCaseExecutor {
    constructor(private middlewares: UseCaseMiddleware[] = []) {}

    async execute&lt;T&gt;(useCase: UseCase&lt;T&gt;, context: UseCaseContext): Promise&lt;UseCaseResult&lt;T&gt;&gt; {
      try {
        // Execute before middlewares
        for (const middleware of this.middlewares) {
          context = await middleware.before(context);
        }

        // Execute use case
        const result = await useCase.execute(context);

        // Execute after middlewares
        let finalResult = result;
        for (const middleware of this.middlewares) {
          finalResult = await middleware.after(finalResult, context);
        }

        return finalResult;
      } catch (error) {
        // Execute error middlewares
        for (const middleware of this.middlewares) {
          await middleware.onError(error as Error, context);
        }
        throw error;
      }
    }
  }

  // LoggingMiddleware
  class LoggingMiddleware implements UseCaseMiddleware {
    constructor(private logger: Logger) {}

    async before(context: UseCaseContext): Promise&lt;UseCaseContext&gt; {
      this.logger.info('Use case execution started', { context });
      return context;
    }

    async after(result: UseCaseResult, context: UseCaseContext): Promise&lt;UseCaseResult&gt; {
      this.logger.info('Use case execution completed', { result, context });
      return result;
    }

    async onError(error: Error, context: UseCaseContext): Promise&lt;void&gt; {
      this.logger.error('Use case execution failed', { error, context });
    }
  }

  // PerformanceMiddleware
  class PerformanceMiddleware implements UseCaseMiddleware {
    private performanceData = new Map&lt;string, PerformanceStats&gt;();

    async before(context: UseCaseContext): Promise&lt;UseCaseContext&gt; {
      (context as any).startTime = Date.now();
      return context;
    }

    async after(result: UseCaseResult, context: UseCaseContext): Promise&lt;UseCaseResult&gt; {
      const executionTime = Date.now() - (context as any).startTime;
      this.performanceData.set((context as any).useCaseName, {
        executionTime,
        timestamp: new Date(),
        success: (result as any).success
      });
      return result;
    }

    getPerformanceStats(useCaseName: string): PerformanceStats | undefined {
      return this.performanceData.get(useCaseName);
    }
  }

  // Usage
  const executor = new UseCaseExecutorImpl([
    new LoggingMiddleware(logger),
    new PerformanceMiddleware(),
    new CachingMiddleware(),
    new ValidationMiddleware()
  ]);

  const result = await executor.execute(userManagementUseCase, {
    useCaseName: 'approveUser',
    requestId: 'req-123',
    timestamp: new Date(),
    metadata: { userId, approvalData }
  });
  </code>
end note

Executor .. N_ImplementationExample
Middlewares .. N_ImplementationExample
Factory .. N_ImplementationExample
Usage .. N_ImplementationExample

@enduml
