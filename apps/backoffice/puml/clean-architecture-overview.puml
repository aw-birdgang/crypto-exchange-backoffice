@startuml Clean Architecture Overview
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title Crypto Exchange Backoffice - Clean Architecture Overview

legend top
  **Clean Architecture Principles:**

  ðŸ—ï¸ **Dependency Rule**: Dependencies point inward only
  ðŸ”„ **Separation of Concerns**: Each layer has distinct responsibilities
  ðŸ§ª **Testability**: Business logic is independent of frameworks
  ðŸ”§ **Maintainability**: Changes in one layer don't affect others
  ðŸ“¦ **Modularity**: Features are self-contained and reusable

  **Architecture Benefits:**
  âœ… Framework independence
  âœ… Easy testing and mocking
  âœ… Clear separation of business logic
  âœ… Scalable and maintainable codebase
  âœ… Technology-agnostic core
end legend

package "Presentation Layer" as Presentation {
  [Pages] as Pages
  [Components] as Components
  [Hooks] as Hooks
}

note right of Presentation
  **Presentation Layer Responsibilities:**

  ðŸŽ¨ **UI Components**: React components for user interface
  ðŸ“„ **Pages**: Route-level components and page layouts
  ðŸª **Custom Hooks**: Business logic integration with UI
  ðŸ”„ **State Management**: Local component state and form handling
  ðŸŽ¯ **User Interactions**: Event handling and user input processing

  **Key Technologies:**
  â€¢ React 18 with TypeScript
  â€¢ React Router for navigation
  â€¢ React Hook Form for form management
  â€¢ Custom hooks for business logic integration
  â€¢ Zustand for global state management
end note

package "Application Layer" as Application {
  [Use Cases] as UseCases
  [Services] as Services
  [Stores] as Stores
}

note right of Application
  **Application Layer Responsibilities:**

  ðŸŽ¯ **Use Cases**: Business logic implementation and orchestration
  ðŸ”§ **Services**: Application-specific business logic and data transformation
  ðŸª **Stores**: Global state management and data persistence
  ðŸ”„ **Coordination**: Orchestrates domain entities and external services
  ðŸ“Š **Data Flow**: Manages data flow between presentation and domain layers

  **Key Patterns:**
  â€¢ Use Case Pattern for business operations
  â€¢ Service Layer for application logic
  â€¢ Repository Pattern for data access abstraction
  â€¢ Factory Pattern for dependency injection
  â€¢ Command/Query separation (CQRS)

  **State Management:**
  â€¢ Zustand stores for global state
  â€¢ TanStack Query for server state
  â€¢ Local state for component-specific data
end note

package "Domain Layer" as Domain {
  [Interfaces] as Interfaces
  [Entities] as Entities
  [Value Objects] as ValueObjects
}

note right of Domain
  **Domain Layer Responsibilities:**

  ðŸ›ï¸ **Core Business Logic**: Pure business rules and domain knowledge
  ðŸ“‹ **Interfaces**: Contracts for external dependencies (Dependency Inversion)
  ðŸ—ï¸ **Entities**: Core business objects with identity and behavior
  ðŸ’Ž **Value Objects**: Immutable objects representing domain concepts
  ðŸ“ **Business Rules**: Validation rules and domain constraints

  **Key Principles:**
  â€¢ Framework-independent pure business logic
  â€¢ No external dependencies (except interfaces)
  â€¢ Rich domain models with behavior
  â€¢ Domain-driven design (DDD) patterns
  â€¢ Business rule encapsulation

  **Domain Concepts:**
  â€¢ AdminUser entity with business rules
  â€¢ Permission and Role value objects
  â€¢ Use case interfaces for business operations
  â€¢ Domain events for business processes
  â€¢ Validation rules and constraints
end note

package "Infrastructure Layer" as Infrastructure {
  [API Services] as APIServices
  [Storage Services] as StorageServices
  [External Services] as ExternalServices
}

note right of Infrastructure
  **Infrastructure Layer Responsibilities:**

  ðŸŒ **API Services**: HTTP client implementations for external APIs
  ðŸ’¾ **Storage Services**: Data persistence and retrieval implementations
  ðŸ”Œ **External Services**: Third-party service integrations
  ðŸ”§ **Technical Concerns**: Framework-specific implementations
  ðŸ“¡ **Data Access**: Repository pattern implementations

  **Key Technologies:**
  â€¢ Axios for HTTP client
  â€¢ React Query for server state management
  â€¢ Local Storage for client-side persistence
  â€¢ RESTful API integration
  â€¢ Error handling and retry logic

  **Implementation Patterns:**
  â€¢ Repository pattern for data access
  â€¢ Adapter pattern for external services
  â€¢ Factory pattern for service creation
  â€¢ Strategy pattern for different implementations
  â€¢ Observer pattern for event handling
end note

' Dependencies (Dependency Rule - inward only)
Presentation --> Application : depends on
Application --> Domain : depends on
Application --> Infrastructure : depends on

note as N_DependencyRule
  **Dependency Rule:**

  ðŸ”„ **Inward Dependencies Only**: Outer layers depend on inner layers
  ðŸš« **No Outward Dependencies**: Inner layers never depend on outer layers
  ðŸŽ¯ **Dependency Inversion**: Use interfaces to invert dependencies
  ðŸ—ï¸ **Stable Core**: Domain layer is the most stable and independent

  **Benefits:**
  âœ… Business logic is framework-independent
  âœ… Easy to test and mock dependencies
  âœ… Technology changes don't affect core logic
  âœ… Clear separation of concerns
end note

Presentation .. N_DependencyRule
Application .. N_DependencyRule
Domain .. N_DependencyRule
Infrastructure .. N_DependencyRule

' Internal dependencies
Pages --> Components
Components --> Hooks
Hooks --> UseCases
Hooks --> Stores
UseCases --> Services
UseCases --> Interfaces
Services --> APIServices
Services --> StorageServices
Services --> ExternalServices

note as N_ImplementationExample
  **Implementation Example:**

  <code>
  // Domain Layer (Pure Business Logic)
  interface UserManagementUseCase {
    approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt;;
  }

  // Application Layer (Use Case Implementation)
  class UserManagementUseCaseImpl implements UserManagementUseCase {
    constructor(private userService: IUserService) {}

    async approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt; {
      // Business logic validation
      this.validateApprovalData(data);
      return await this.userService.approveUser(userId, data);
    }
  }

  // Infrastructure Layer (API Implementation)
  class ApiUserService implements IUserService {
    async approveUser(userId: string, data: UserApprovalRequest): Promise&lt;AdminUser&gt; {
      return await this.apiClient.put(`/users/${userId}/approve`, data);
    }
  }

  // Presentation Layer (React Hook)
  const useUserApproval = () =&gt; {
    return useMutation({
      mutationFn: (data) => useCaseFactory.getUserManagementUseCase().approveUser(data.userId, data),
    });
  };
  </code>
end note

Presentation .. N_ImplementationExample
Application .. N_ImplementationExample
Domain .. N_ImplementationExample
Infrastructure .. N_ImplementationExample

@enduml
