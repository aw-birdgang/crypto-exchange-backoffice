@startuml Dependency Injection
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title Dependency Injection Pattern

legend top
  **Dependency Injection (DI) Pattern Overview:**

  üèóÔ∏è **Core Principle**: Dependencies are provided from outside rather than created internally
  üîÑ **Inversion of Control**: High-level modules don't depend on low-level modules
  üß™ **Testability**: Easy to mock dependencies for unit testing
  üîß **Flexibility**: Can swap implementations without changing business logic
  üì¶ **Modularity**: Promotes loose coupling and high cohesion

  **Benefits:**
  ‚úÖ Easier testing and mocking
  ‚úÖ Better separation of concerns
  ‚úÖ Increased code reusability
  ‚úÖ Simplified configuration management
  ‚úÖ Improved maintainability
end legend

package "Current Implementation (Factory Pattern)" as Current {
  class "UseCaseFactory" as Factory {
    - static userService: AdminUserService
    - static userManagementUseCase: UserManagementUseCase
    + static setUserService(service): void
    + static getUserManagementUseCase(): UserManagementUseCase
    + static initialize(service): void
  }

  class "UserManagementUseCaseImpl" as UseCaseImpl {
    - userService: AdminUserService
    + getAllUsers(filters): AdminUser[]
  }

  class "AdminUserService" as UserService {
    + getAllUsers(filters): AdminUser[]
  }

  Factory --> UseCaseImpl : creates
  Factory --> UserService : manages
  UseCaseImpl --> UserService : depends on
}

note right of Current
  **Current Factory Pattern Implementation:**

  üè≠ **Factory Pattern Benefits**:
  ‚Ä¢ Centralized object creation
  ‚Ä¢ Simple dependency management
  ‚Ä¢ Clear service instantiation
  ‚Ä¢ Easy to understand and implement

  ‚ö†Ô∏è **Current Limitations**:
  ‚Ä¢ Static dependencies (hard to test)
  ‚Ä¢ Global state management
  ‚Ä¢ Limited flexibility for different environments
  ‚Ä¢ No lifecycle management
  ‚Ä¢ Difficult to mock for testing

  **Code Example**:
  <code>
  class UseCaseFactory {
    private static userService: AdminUserService;

    static initialize(service: AdminUserService) {
      this.userService = service;
    }

    static getUserManagementUseCase() {
      return new UserManagementUseCaseImpl(this.userService);
    }
  }
  </code>
end note

package "Improved Implementation (DI Container)" as Improved {
  class "DIContainer" as Container {
    - services: Map
    - factories: Map
    + register(token, implementation): void
    + registerFactory(token, factory): void
    + resolve(token)
  }

  interface "IUserService" as IUserService {
    + getAllUsers(filters): AdminUser[]
  }

  class "UserManagementUseCaseImpl" as ImprovedUseCaseImpl {
    - userService: IUserService
    + getAllUsers(filters): AdminUser[]
  }

  class "ApiUserService" as ApiUserService {
    + getAllUsers(filters): AdminUser[]
  }

  class "MockUserService" as MockUserService {
    + getAllUsers(filters): AdminUser[]
  }

  Container --> ImprovedUseCaseImpl : creates
  Container --> ApiUserService : manages
  Container --> MockUserService : manages
  ImprovedUseCaseImpl --> IUserService : depends on
  ApiUserService ..|> IUserService : implements
  MockUserService ..|> IUserService : implements
}

note right of Improved
  **Improved DI Container Implementation:**

  üèóÔ∏è **DI Container Benefits**:
  ‚Ä¢ Dynamic dependency resolution
  ‚Ä¢ Interface-based programming
  ‚Ä¢ Easy testing with mock implementations
  ‚Ä¢ Lifecycle management
  ‚Ä¢ Environment-specific configurations

  üîß **Key Features**:
  ‚Ä¢ Service registration and resolution
  ‚Ä¢ Factory pattern support
  ‚Ä¢ Singleton and transient scopes
  ‚Ä¢ Circular dependency detection
  ‚Ä¢ Type-safe resolution

  **Code Example**:
  <code>
  class DIContainer {
    private services = new Map&lt;string, any&gt;();

    register(token: string, implementation: any) {
      this.services.set(token, implementation);
    }

    resolve(token: string): any {
      return this.services.get(token);
    }
  }

  // Usage
  container.register('IUserService', new ApiUserService());
  const useCase = new UserManagementUseCaseImpl(
    container.resolve('IUserService') as IUserService
  );
  </code>
end note

package "React Context DI" as ReactDI {
  class "DIProvider" as DIProvider {
    + container: DIContainer
  }

  class "useDI Hook" as UseDIHook {
    + useDI(): DIContainer
  }

  class "useUsers Hook" as UseUsersHook {
    + useUsers(filters): UseQueryResult
  }

  DIProvider --> UseDIHook : provides
  UseDIHook --> UseUsersHook : uses
  UseUsersHook --> Container : resolves dependencies
}

note right of ReactDI
  **React Context DI Implementation:**

  ‚öõÔ∏è **React Integration Benefits**:
  ‚Ä¢ Component-level dependency injection
  ‚Ä¢ Hook-based service access
  ‚Ä¢ Provider pattern for DI container
  ‚Ä¢ Context-based service sharing
  ‚Ä¢ Type-safe service resolution

  üîß **Implementation Pattern**:
  ‚Ä¢ DIProvider wraps the application
  ‚Ä¢ useDI hook provides container access
  ‚Ä¢ Custom hooks resolve dependencies
  ‚Ä¢ Services are injected at hook level

  **Code Example**:
  <code>
  const DIContext = createContext&lt;DIContainer | null&gt;(null);

  export const DIProvider = ({ children }) =&gt; {
    const container = useMemo(() =&gt; new DIContainer(), []);
    return (
      &lt;DIContext.Provider value={container}&gt;
        {children}
      &lt;/DIContext.Provider&gt;
    );
  };

  export const useDI = () =&gt; {
    const container = useContext(DIContext);
    if (!container) throw new Error('useDI must be used within DIProvider');
    return container;
  };

  export const useUsers = (filters) =&gt; {
    const container = useDI();
    const userService = container.resolve('IUserService') as IUserService;
    return useQuery(['users', filters], () =&gt; userService.getAllUsers(filters));
  };
  </code>
end note

' Migration Strategy
note as N_MigrationStrategy
  **Migration Strategy from Factory to DI Container:**

  üöÄ **Phase 1: Interface Extraction**
  ‚Ä¢ Extract interfaces from concrete implementations
  ‚Ä¢ Define service contracts
  ‚Ä¢ Create abstraction layer

  üîß **Phase 2: DI Container Implementation**
  ‚Ä¢ Implement basic DI container
  ‚Ä¢ Add service registration
  ‚Ä¢ Create factory methods

  ‚öõÔ∏è **Phase 3: React Integration**
  ‚Ä¢ Create DIProvider component
  ‚Ä¢ Implement useDI hook
  ‚Ä¢ Update custom hooks to use DI

  üß™ **Phase 4: Testing & Validation**
  ‚Ä¢ Add mock implementations
  ‚Ä¢ Update unit tests
  ‚Ä¢ Validate functionality

  üìä **Phase 5: Performance Optimization**
  ‚Ä¢ Add service caching
  ‚Ä¢ Implement lazy loading
  ‚Ä¢ Monitor performance impact
end note

Current .. N_MigrationStrategy
Improved .. N_MigrationStrategy
ReactDI .. N_MigrationStrategy

' Benefits Comparison
note right of Current
  **Current Factory Pattern:**

  ‚úÖ **Pros**:
  ‚Ä¢ Simple implementation
  ‚Ä¢ Clear dependencies
  ‚Ä¢ Easy to understand
  ‚Ä¢ Minimal setup required

  ‚ùå **Cons**:
  ‚Ä¢ Static dependencies
  ‚Ä¢ Hard to test
  ‚Ä¢ Limited flexibility
  ‚Ä¢ Global state issues
  ‚Ä¢ No lifecycle management
end note

note right of Improved
  **Improved DI Container:**

  ‚úÖ **Pros**:
  ‚Ä¢ Dynamic dependencies
  ‚Ä¢ Easy testing with mocks
  ‚Ä¢ High flexibility
  ‚Ä¢ Interface-based design
  ‚Ä¢ Lifecycle management
  ‚Ä¢ Environment-specific configs

  ‚ùå **Cons**:
  ‚Ä¢ More complex setup
  ‚Ä¢ Learning curve
  ‚Ä¢ Potential over-engineering
  ‚Ä¢ Runtime dependency resolution
end note

note right of ReactDI
  **React Context DI:**

  ‚úÖ **Pros**:
  ‚Ä¢ React integration
  ‚Ä¢ Component-level DI
  ‚Ä¢ Hook-based usage
  ‚Ä¢ Provider pattern
  ‚Ä¢ Type-safe resolution
  ‚Ä¢ Context-based sharing

  ‚ùå **Cons**:
  ‚Ä¢ React-specific
  ‚Ä¢ Context re-render issues
  ‚Ä¢ Provider nesting complexity
  ‚Ä¢ Hook dependency on context
end note

@enduml
