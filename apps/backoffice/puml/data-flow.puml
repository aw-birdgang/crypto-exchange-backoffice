@startuml Data Flow
!theme plain
skinparam componentStyle uml2
skinparam shadowing false
skinparam roundcorner 15
skinparam monochrome true
skinparam backgroundColor #F9F9F9
skinparam ArrowColor Black
skinparam ArrowFontColor Black
skinparam defaultFontName "Nanum Gothic"

title Data Flow Architecture

note top
  **Data Flow Architecture Overview:**
  
  ðŸ”„ **Unidirectional Data Flow**: Data flows in one direction through the application
  ðŸŽ¯ **Single Source of Truth**: Each piece of data has one authoritative source
  ðŸ”„ **Predictable State Updates**: State changes follow a clear, traceable pattern
  ðŸ§ª **Testable Flow**: Each step can be tested independently
  ðŸ“Š **Performance Optimized**: Efficient data flow with minimal re-renders
  
  **Key Principles:**
  âœ… User actions trigger data flow
  âœ… Business logic validates and processes data
  âœ… External services handle data persistence
  âœ… UI updates reflect current state
  âœ… Error handling provides user feedback
end note

actor "User" as User
participant "Component" as Component
participant "Hook" as Hook
participant "Use Case" as UseCase
participant "Service" as Service
participant "API" as API
participant "Database" as DB

note right of User
  **User Interaction Layer:**
  
  ðŸ‘¤ **User Actions**: Clicks, form submissions, navigation
  ðŸŽ¯ **Intent**: User wants to perform specific operations
  ðŸ“± **UI Feedback**: Loading states, success/error messages
  ðŸ”„ **State Changes**: UI updates based on operation results
end note

note right of Component
  **React Component Layer:**
  
  ðŸŽ¨ **UI Rendering**: Displays data and handles user interactions
  ðŸª **Hook Integration**: Uses custom hooks for business logic
  ðŸ“Š **State Management**: Local state for UI-specific data
  ðŸ”„ **Re-rendering**: Updates UI when data changes
  ðŸŽ¯ **Event Handling**: Processes user interactions
end note

note right of Hook
  **Custom Hook Layer:**
  
  ðŸ”— **Business Logic Bridge**: Connects UI to business logic
  ðŸ“Š **State Orchestration**: Manages complex state interactions
  ðŸ”„ **Data Synchronization**: Keeps UI and server state in sync
  ðŸ§ª **Reusable Logic**: Encapsulates business logic for reuse
  ðŸ“¡ **API Integration**: Handles data fetching and mutations
end note

note right of UseCase
  **Use Case Layer:**
  
  ðŸŽ¯ **Business Logic**: Implements specific business operations
  âœ… **Validation**: Validates input data and business rules
  ðŸ”„ **Orchestration**: Coordinates between different services
  ðŸ“Š **Data Transformation**: Converts data between layers
  ðŸ›¡ï¸ **Error Handling**: Manages business logic errors
end note

note right of Service
  **Service Layer:**
  
  ðŸŒ **API Communication**: Handles HTTP requests and responses
  ðŸ”„ **Data Transformation**: Converts between API and domain models
  ðŸ›¡ï¸ **Error Handling**: Manages network and API errors
  ðŸ“Š **Caching**: Implements caching strategies
  ðŸ”§ **Configuration**: Manages API endpoints and settings
end note

note right of API
  **API Gateway Layer:**
  
  ðŸŒ **HTTP Server**: Handles incoming requests
  ðŸ” **Authentication**: Validates user credentials and permissions
  ðŸ“Š **Business Logic**: Server-side business rule enforcement
  ðŸ’¾ **Data Access**: Coordinates with database operations
  ðŸ“¡ **Response Formatting**: Returns standardized API responses
end note

note right of DB
  **Database Layer:**
  
  ðŸ’¾ **Data Persistence**: Stores and retrieves application data
  ðŸ”’ **Data Integrity**: Enforces data constraints and relationships
  ðŸ“Š **Query Optimization**: Efficient data retrieval
  ðŸ”„ **Transactions**: Ensures data consistency
  ðŸ“ˆ **Performance**: Handles concurrent access and scaling
end note

== User Action Flow (Success Path) ==

note over User, DB
  **Success Flow Steps:**
  
  1ï¸âƒ£ **User Interaction**: User initiates action
  2ï¸âƒ£ **Component Handling**: UI processes user input
  3ï¸âƒ£ **Hook Orchestration**: Custom hook manages state
  4ï¸âƒ£ **Use Case Execution**: Business logic validation
  5ï¸âƒ£ **Service Communication**: API call preparation
  6ï¸âƒ£ **API Processing**: Server-side business logic
  7ï¸âƒ£ **Database Update**: Data persistence
  8ï¸âƒ£ **Response Chain**: Data flows back through layers
  9ï¸âƒ£ **UI Update**: User sees success feedback
end note

User -> Component : User clicks "Approve User"
activate Component
note right : User initiates approval action

Component -> Hook : calls useUserApproval()
activate Hook
note right : Component delegates to custom hook

Hook -> UseCase : calls approveUser(userId, data)
activate UseCase
note right : Hook calls business logic

UseCase -> UseCase : validateApprovalData(data)
note right : Input validation
UseCase -> UseCase : business logic validation
note right : Business rule validation

UseCase -> Service : calls approveUser(userId, data)
activate Service
note right : Use case delegates to service

Service -> API : PUT /admin/users/:userId/approve
activate API
note right : HTTP request to API

API -> DB : UPDATE users SET status='APPROVED'
activate DB
note right : Database update
DB --> API : success response
deactivate DB

API --> Service : HTTP 200 + user data
deactivate API
note right : API returns success response

Service --> UseCase : returns AdminUser
deactivate Service
note right : Service returns domain object

UseCase --> Hook : returns AdminUser
deactivate UseCase
note right : Use case returns result

Hook -> Hook : update React Query cache
note right : Update client cache
Hook -> Hook : invalidate related queries
note right : Trigger refetch of related data
Hook --> Component : mutation success
deactivate Hook
note right : Hook notifies success

Component -> Component : update UI state
note right : Update local state
Component --> User : show success message
deactivate Component
note right : User sees success feedback

== Error Handling Flow ==

note over User, DB
  **Error Handling Flow:**
  
  ðŸš¨ **Error Types**:
  â€¢ Validation Errors (client-side)
  â€¢ Business Logic Errors (use case)
  â€¢ Network Errors (service layer)
  â€¢ Server Errors (API layer)
  â€¢ Database Errors (persistence layer)
  
  ðŸ›¡ï¸ **Error Handling Strategy**:
  â€¢ Graceful degradation
  â€¢ User-friendly error messages
  â€¢ Error logging and monitoring
  â€¢ Retry mechanisms where appropriate
  â€¢ Fallback UI states
end note

User -> Component : User clicks "Approve User"
activate Component
note right : User initiates action

Component -> Hook : calls useUserApproval()
activate Hook
note right : Component delegates to hook

Hook -> UseCase : calls approveUser(userId, data)
activate UseCase
note right : Hook calls business logic

UseCase -> UseCase : validateApprovalData(data)
note right : Input validation fails
UseCase --> Hook : throws ValidationError
deactivate UseCase
note right : Business validation error

Hook -> Hook : handle error
note right : Error processing and logging
Hook --> Component : mutation error
deactivate Hook
note right : Hook returns error state

Component -> Component : show error message
note right : Update UI with error state
Component --> User : display error
deactivate Component
note right : User sees error feedback

== Network Error Flow ==

User -> Component : User clicks "Approve User"
activate Component

Component -> Hook : calls useUserApproval()
activate Hook

Hook -> UseCase : calls approveUser(userId, data)
activate UseCase

UseCase -> Service : calls approveUser(userId, data)
activate Service

Service -> API : PUT /admin/users/:userId/approve
activate API

API --> Service : HTTP 500 Internal Server Error
deactivate API
note right : Server error response

Service --> UseCase : throws NetworkError
deactivate Service
note right : Service throws network error

UseCase --> Hook : throws NetworkError
deactivate UseCase
note right : Use case propagates error

Hook -> Hook : handle error
note right : Error handling and retry logic
Hook --> Component : mutation error
deactivate Hook
note right : Hook returns error state

Component -> Component : show error message
note right : Display network error message
Component --> User : display error
deactivate Component
note right : User sees error feedback

== Cache Invalidation Flow ==

note over Hook, UseCase
  **Cache Management Strategy:**
  
  ðŸ”„ **After Successful Mutation**:
  1. Update optimistic cache with new data
  2. Invalidate related queries to trigger refetch
  3. Update dependent queries with fresh data
  4. Maintain cache consistency across components
  
  ðŸ“Š **Cache Invalidation Patterns**:
  â€¢ Exact key invalidation
  â€¢ Pattern-based invalidation
  â€¢ Dependent query updates
  â€¢ Optimistic updates
end note

Hook -> Hook : queryClient.invalidateQueries(['users'])
note right : Invalidate user list queries
Hook -> Hook : queryClient.setQueryData(['users'], updatedData)
note right : Update cache with new data
Hook -> Hook : queryClient.invalidateQueries(['user', userId])
note right : Invalidate specific user queries

== State Synchronization ==

note over Component, Hook
  **State Synchronization Strategy:**
  
  ðŸ”„ **Multi-Layer State Management**:
  â€¢ **Local State** (useState): Component-specific UI state
  â€¢ **Global State** (Zustand): Application-wide shared state
  â€¢ **Server State** (TanStack Query): Cached server data
  
  ðŸ“Š **State Synchronization Patterns**:
  â€¢ Reactive updates across components
  â€¢ Optimistic updates for better UX
  â€¢ Conflict resolution strategies
  â€¢ State persistence and hydration
end note

Component -> Hook : subscribes to state changes
note right : Component subscribes to state updates
Hook -> Component : notifies state updates
note right : Hook notifies component of changes

== Performance Optimization Flow ==

note over Component, DB
  **Performance Optimization Strategies:**
  
  âš¡ **Rendering Optimization**:
  â€¢ React.memo for component memoization
  â€¢ useMemo for expensive calculations
  â€¢ useCallback for stable function references
  â€¢ Virtual scrolling for large lists
  
  ðŸ“Š **Data Optimization**:
  â€¢ Pagination for large datasets
  â€¢ Debouncing for search inputs
  â€¢ Request deduplication
  â€¢ Background refetching
  
  ðŸš€ **Network Optimization**:
  â€¢ Request batching
  â€¢ Response caching
  â€¢ Compression
  â€¢ CDN utilization
end note

Component -> Hook : debounced search input
note right : Debounced user input
Hook -> Hook : debounce search query
note right : Debounce implementation
Hook -> UseCase : calls searchUsers(query)
note right : Optimized search call
UseCase -> Service : calls searchUsers(query)
note right : Service call with caching
Service -> API : GET /users/search?q=query
note right : Cached API request

@enduml
